import logging
from typing import AsyncGenerator
from google.adk.agents import LlmAgent
from google.adk.events import Event
from google.adk.agents.invocation_context import InvocationContext
from google.genai import types
import re

from level5.utils import extract_text_from_message
from prompts import SCRIPT_GENERATOR_INSTRUCTION

logger = logging.getLogger(__name__)

# --- Constants from constants_and_models.py ---
MODEL_GEMINI_2_FLASH = "gemini-2.0-flash-exp"

# --- Script Generator Agent ---
class ScriptGeneratorAgent(LlmAgent):
    name: str = "ScriptGeneratorAgent"
    
    def __init__(self, name: str = "ScriptGeneratorAgent", model: str = MODEL_GEMINI_2_FLASH):
        super().__init__(
            name=name,
            model=model,
            instruction=SCRIPT_GENERATOR_INSTRUCTION,
            input_schema=None,
            output_key="podcast_script"
        )
    
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        logger.info(f"[{self.name}] Starting podcast script generation.")
        input_text = ctx.session.state.get("input_text", "")

        if not input_text:
            input_text = ctx.session.state.get("processing_instructions", "")

        if not input_text:
            routing_decision = ctx.session.state.get("parsed_routing_decision", {})
            if isinstance(routing_decision, dict):
                input_text = routing_decision.get("instructions", "")

        if input_text:
            input_text = re.sub(r'^(Generate|Create)\s+a\s+podcast\s+script\s+(about|for|on)\s*', '', input_text, flags=re.IGNORECASE).strip()

        if not input_text:
            error_response = "Error: No input provided for script generation."
            yield Event(
                content=types.Content(
                    role='assistant',
                    parts=[types.Part(text=error_response)]
                ),
                author=self.name
            )
            return

        try:
            ctx.session.state["input_text"] = input_text
            script_text = ""
            async for event in super()._run_async_impl(ctx):
                if event.content and event.content.parts:
                    script_text = extract_text_from_message(event.content)
                    break

            if not script_text:
                raise ValueError("No script generated by LLM.")

            ctx.session.state["podcast_script"] = script_text

            response_text = f"""
üìù Podcast Script Generated Successfully:
- Topic: {input_text[:50]}{'...' if len(input_text) > 50 else ''}
- Script stored in session state under 'podcast_script'
- Preview: {script_text[:100]}{'...' if len(script_text) > 100 else ''}
            """.strip()

            yield Event(
                content=types.Content(
                    role='assistant',
                    parts=[types.Part(text=response_text)]
                ),
                author=self.name
            )
        except Exception as e:
            error_response = f"‚ùå Error generating podcast script: {str(e)}"
            yield Event(
                content=types.Content(
                    role='assistant',
                    parts=[types.Part(text=error_response)]
                ),
                author=self.name
            )